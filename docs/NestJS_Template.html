<!doctype html>
<!-- saved from url=(0110)http://127.0.0.1:3000/proto/NestJS%20Template%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20%EB%B0%9C%ED%91%9C.html -->
<html lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script
      type="text/javascript"
      src="./NestJS Template 프로젝트 발표_files/___vscode_livepreview_injected_script"
    ></script>

    <script
      type="text/javascript"
      src="./NestJS Template 프로젝트 발표_files/___vscode_livepreview_injected_script(1)"
    ></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NestJS Template 프로젝트 발표</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
        color: #ffffff;
        overflow: hidden;
      }

      .presentation-container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .slide {
        display: none;
        width: 90%;
        max-width: 1200px;
        background: rgba(40, 40, 40, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 60px;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: slideIn 0.6s ease-out;
      }

      .slide.active {
        display: block;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      h1 {
        color: #ffffff;
        font-size: 3rem;
        margin-bottom: 1rem;
        text-align: center;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      h2 {
        color: #ffffff;
        font-size: 2.5rem;
        margin-bottom: 2rem;
        text-align: center;
        border-bottom: 3px solid #ffd700;
        padding-bottom: 1rem;
      }

      h3 {
        font-size: 1.8rem;
        margin: 1.5rem 0 1rem 0;
        color: #87ceeb;
      }

      h4 {
        color: #ffffff;
        font-size: 1.4rem;
        margin: 1.5rem 0 1rem 0;
      }

      p {
        font-size: 1.2rem;
        line-height: 1.8;
        margin-bottom: 1rem;
        text-align: center;
      }

      ul {
        font-size: 1.1rem;
        line-height: 1.8;
        margin-left: 2rem;
        margin-bottom: 1.5rem;
      }

      li {
        margin-bottom: 0.8rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 2rem;
        margin: 2rem 0;
      }

      .stat-card {
        background: linear-gradient(135deg, #87ceeb 0%, #4fc3f7 100%);
        color: #000000;
        padding: 2rem;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        transition: transform 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 30px rgba(135, 206, 235, 0.3);
      }

      .stat-number {
        font-size: 3rem;
        font-weight: bold;
        display: block;
        margin-bottom: 1rem;
      }

      .code-block {
        background: #000000;
        color: #ffffff;
        padding: 1.5rem;
        border-radius: 10px;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        line-height: 1.6;
        margin: 1.5rem 0;
        overflow-x: auto;
        overflow-y: auto;
        max-height: 600px;
        border-left: 5px solid #ffd700;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 2rem 0;
        background: #2a2a2a;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      }

      .comparison-table th {
        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
        color: #000000;
        padding: 1rem;
        text-align: left;
        font-weight: 600;
      }

      .comparison-table td {
        padding: 1rem;
        border-bottom: 1px solid #444444;
        color: #ffffff;
      }

      .comparison-table tr:hover {
        background: #3a3a3a;
      }

      .architecture-diagram {
        text-align: center;
        margin: 2rem 0;
      }

      .layer {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        margin: 0.5rem 0;
        border-radius: 10px;
        font-weight: 600;
      }

      .arrow {
        font-size: 2rem;
        color: #667eea;
        margin: 0.5rem 0;
      }

      .highlight {
        background: linear-gradient(135deg, #667eea 0%, #fab1a0 100%);
        padding: 0.2rem 0.5rem;
        border-radius: 5px;
        font-weight: 600;
      }

      .center {
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100%;
        min-height: 60vh;
      }

      .slide-counter {
        position: fixed;
        top: 30px;
        right: 30px;
        background: rgba(40, 40, 40, 0.9);
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div class="slide-counter">
      <span id="current-slide">8</span> / <span id="total-slides">15</span>
    </div>

    <div class="presentation-container">
      <!-- Slide 1: 제목 -->
      <div class="slide">
        <div class="center">
          <h1>🚀 NestJS Template 프로젝트</h1>
          <h3>마이크로서비스 + Onion Architecture + CQRS</h3>
        </div>
      </div>

      <!-- Slide 2: 프로젝트 개요 -->
      <div class="slide">
        <h2>📋 프로젝트 개요</h2>

        <h3>🎯 핵심 경험 및 학습 목표</h3>
        <ul>
          <li>
            <strong>마이크로서비스 아키텍처 경험</strong> - 서비스 분리, 독립
            배포, 확장성
          </li>
          <li><strong>모노레포 관리 경험</strong> - 코드 공유, 의존성 관리</li>
          <li>
            <strong>도메인 경계 기반 서비스 분리</strong> - 도메인 및 HTTP/gRPC
            프로토콜 선택에 따른 분리
          </li>
          <li>
            <strong>OAuth 2.0 &amp; JWT 인증 경험</strong> - 토큰 기반 인증,
            보안 설계
          </li>
          <li>
            <strong>NestJS 프레임워크 경험</strong> - 의존성 주입, 모듈 시스템,
            데코레이터
          </li>
          <li>
            <strong>CQRS 패턴 경험</strong> - 명령/조회 분리, 이벤트 기반
            아키텍처
          </li>
          <li>
            <strong>Optimistic Lock 경험</strong> - 동시성 제어, 성능 최적화
          </li>
        </ul>
      </div>

      <!-- Slide 3: NestJS 소개 -->
      <div class="slide">
        <h2>🔥 NestJS란?</h2>

        <h3>💡 핵심 특징</h3>
        <ul>
          <li><strong>TypeScript 기반</strong> - 타입 안정성과 개발 생산성</li>
          <li>
            <strong>Decorator 패턴</strong> - 메타데이터 기반 선언적 프로그래밍
          </li>
          <li><strong>의존성 주입(DI)</strong> - IoC 컨테이너로 느슨한 결합</li>
          <li><strong>모듈 시스템</strong> - 기능별 캡슐화와 재사용성</li>
          <li><strong>Express/Fastify</strong> 기반 - 검증된 HTTP 서버</li>
        </ul>

        <h3>🎨 주요 구성 요소</h3>
        <div class="code-block">
          @Controller('users')<br />
          export class UserController {<br />
          &nbsp;&nbsp;constructor(private userService: UserService) {}<br />
          <br />
          &nbsp;&nbsp;@Get(':id')<br />
          &nbsp;&nbsp;@UseGuards(JwtAuthGuard)<br />
          &nbsp;&nbsp;async getUser(@Param('id') id: string) {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;return this.userService.findById(id);<br />
          &nbsp;&nbsp;}<br />
          }
        </div>

        <p>
          <strong>Controller</strong>, <strong>Service</strong>,
          <strong>Guard</strong>, <strong>Interceptor</strong>,
          <strong>Filter</strong> 등의 구성 요소로 깔끔한 아키텍처 구성
        </p>
      </div>

      <!-- Slide 4: IOC/DI -->
      <div class="slide">
        <h2>🔄 IOC/DI (Inversion of Control / Dependency Injection)</h2>

        <h3>💡 제어의 역전과 의존성 주입</h3>
        <ul>
          <li>
            <strong>IOC Container</strong> - NestJS가 객체 생성과 생명주기 관리
          </li>
          <li>
            <strong>Constructor Injection</strong> - 생성자를 통한 의존성 주입
          </li>
        </ul>

        <h3>⚙️ NestJS 구현</h3>
        <div class="code-block">
          @Injectable()<br />
          export class AuthService {<br />
          &nbsp;&nbsp;constructor(<br />
          &nbsp;&nbsp;&nbsp;&nbsp;@Inject('IAuthRepository')<br />
          &nbsp;&nbsp;&nbsp;&nbsp;private readonly authRepository:
          IAuthRepository,<br />
          &nbsp;&nbsp;&nbsp;&nbsp;private readonly jwtProvider: IJwtProvider,<br />
          &nbsp;&nbsp;) {}<br />
          }<br />
          <br />
          // Module에서 Provider 등록<br />
          providers: [<br />
          &nbsp;&nbsp;{ provide: 'IAuthRepository', useClass: AuthRepository
          },<br />
          &nbsp;&nbsp;JwtProvider,<br />
          ]
        </div>
      </div>

      <!-- Slide 5: DIP -->
      <div class="slide">
        <h2>🔀 DIP (Dependency Inversion Principle)</h2>

        <h3>💡 의존성 역전 원칙</h3>
        <ul>
          <li><strong>고수준 모듈</strong> - 저수준 모듈에 의존하지 않음</li>
          <li>
            <strong>추상화 의존</strong> - 구체적인 구현이 아닌 인터페이스에
            의존
          </li>
          <li>
            <strong>계층 간 결합도 감소</strong> - 도메인이 인프라에 의존하지
            않음
          </li>
          <li><strong>테스트 용이성</strong> - Mock 객체로 쉬운 단위 테스트</li>
        </ul>

        <h3>🏗️ 실제 구현 예시</h3>
        <div class="code-block">
          // Domain Layer - Interface 정의<br />
          export interface IAuthRepository {<br />
          &nbsp;&nbsp;findById(sessionId: string): Promise&lt;Auth |
          null&gt;;<br />
          &nbsp;&nbsp;save(auth: Auth): Promise&lt;void&gt;;<br />
          }<br />
          <br />
          // Infrastructure Layer - 구현체<br />
          @Injectable()<br />
          export class AuthRepository implements IAuthRepository {<br />
          &nbsp;&nbsp;constructor(<br />
          &nbsp;&nbsp;&nbsp;&nbsp;@InjectRepository(AuthEntity)<br />
          &nbsp;&nbsp;&nbsp;&nbsp;private readonly authRepository:
          Repository&lt;AuthEntity&gt;<br />
          &nbsp;&nbsp;) {}<br />
          }<br />
          <br />
          // Application Layer - 인터페이스에 의존<br />
          constructor(<br />
          &nbsp;&nbsp;@Inject('IAuthRepository')<br />
          &nbsp;&nbsp;private readonly authRepository: IAuthRepository<br />
          ) {}
        </div>
      </div>

      <!-- Slide 6: Onion Architecture -->
      <div class="slide">
        <h2>🧅 Onion Architecture</h2>

        <h3>🎯 핵심 원칙</h3>
        <ul>
          <li>
            <strong>의존성 역전</strong> - 내부 계층이 외부 계층에 의존하지 않음
          </li>
          <li><strong>도메인 중심</strong> - 비즈니스 로직이 핵심</li>
          <li><strong>테스트 용이성</strong> - 각 계층의 독립적 테스트</li>
          <li>
            <strong>기술 독립성</strong> - 프레임워크나 DB에 종속되지 않음
          </li>
        </ul>

        <div class="architecture-diagram">
          <div class="layer">
            <div class="layer-box infrastructure-layer">
              Infrastructure Layer<br />(Repositories, Adapters, DB)
            </div>
          </div>
          <div class="flow-arrow">↓</div>
          <div class="layer">
            <div class="layer-box interface-layer">
              Interface Layer<br />(Controllers, Guards, Filters)
            </div>
          </div>
          <div class="flow-arrow">↓</div>
          <div class="layer">
            <div class="layer-box application-layer">
              Application Layer<br />(Commands, Queries, Handlers)
            </div>
          </div>
          <div class="flow-arrow">↓</div>
          <div class="layer">
            <div class="layer-box domain-layer">
              Domain Layer<br />(Entities, Value Objects, Events)
            </div>
          </div>
        </div>

        <div class="code-block">
          // Domain Layer - 순수 비즈니스 로직<br />
          export class User extends AggregateRoot {<br />
          &nbsp;&nbsp;public updateEmail(newEmail: string): void {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;this.email = new EmailVO(newEmail);<br />
          &nbsp;&nbsp;}<br />
          }
        </div>
      </div>

      <!-- Slide 7: 프로젝트 구조 -->
      <div class="slide">
        <h2>📁 프로젝트 구조</h2>

        <h3>🏢 모노레포 구성</h3>
        <div class="code-block">
          nestjs-template/<br />
          ├── apps/<br />
          │ ├── auth/ # 인증 서비스<br />
          │ ├── user/ # 사용자 HTTP API (external)<br />
          │ └── user-grpc/ # 사용자 gRPC 서비스 (internal)<br />
          ├── libs/<br />
          │ ├── common/ # 공통 라이브러리<br />
          │ └── user-common/ # 사용자 도메인 공통 (Shared Database)<br />
          └── proto/ # gRPC 프로토콜 정의
        </div>

        <h3>🎯 서비스별 계층 구조</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>계층</th>
              <th>역할</th>
              <th>예시</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Infrastructure</strong></td>
              <td>기술 구현</td>
              <td>Repositories, DB</td>
            </tr>
            <tr>
              <td><strong>Interface</strong></td>
              <td>외부 통신</td>
              <td>Controllers, Guards</td>
            </tr>
            <tr>
              <td><strong>Application</strong></td>
              <td>유스케이스</td>
              <td>Commands, Queries</td>
            </tr>
            <tr>
              <td><strong>Domain</strong></td>
              <td>비즈니스 로직</td>
              <td>Entities, Events</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Slide 8: gRPC 통신 -->
      <div class="slide">
        <h2>⚡ gRPC 통신</h2>

        <h3>🚀 마이크로서비스에서 gRPC를 선택한 이유</h3>
        <ul>
          <li>
            <strong>서비스 분리</strong> - 외부(REST) vs 내부(gRPC) 통신 분리
          </li>
          <li>
            <strong>서비스 계약 관리</strong> - .proto 파일로 명확한 API 계약
            정의
          </li>
          <li>
            <strong>운영 효율성</strong> - HTTP/2 멀티플렉싱 + 자동 로드밸런싱
          </li>
        </ul>

        <h3>📋 Proto 정의</h3>
        <div class="code-block">
          service UserService {<br />
          &nbsp;&nbsp;rpc FindOrCreateUser(FindOrCreateUserRequest) returns
          (User) {}<br />
          &nbsp;&nbsp;rpc SoftDeleteUser(SoftDeleteUserRequest) returns
          (SoftDeleteUserResponse) {}<br />
          &nbsp;&nbsp;rpc QueryUsers(stream PaginationDto) returns (stream
          Users) {}<br />
          }<br />
          <br />
          message User {<br />
          &nbsp;&nbsp;string id = 1;<br />
          &nbsp;&nbsp;string email = 2;<br />
          &nbsp;&nbsp;UserStatus status = 3;<br />
          }
        </div>

        <p>
          <strong
            >외부 클라이언트 → auth 서비스 (REST) → user-grpc 서비스
            (gRPC)</strong
          >
        </p>

        <h3>💡 통신 패턴 분리 이유</h3>
        <ul>
          <li><strong>외부 REST</strong> - 브라우저 호환성, 캐싱, 표준화</li>
          <li>
            <strong>내부 gRPC</strong> - 성능, 타입 안전성, 계약 관리 용이
          </li>
        </ul>
      </div>

      <!-- Slide 9: CQRS 패턴 -->
      <div class="slide">
        <h2>🔄 CQRS 패턴</h2>

        <h3>💡 Command Query Responsibility Segregation</h3>
        <ul>
          <li><strong>읽기/쓰기 분리</strong> - 각각 최적화된 모델 사용</li>
          <li><strong>확장성</strong> - 읽기/쓰기 독립적 스케일링</li>
          <li><strong>복잡성 관리</strong> - 비즈니스 로직의 명확한 분리</li>
        </ul>

        <h3>🎯 구현 예시</h3>
        <div class="code-block">
          // Command<br />
          @CommandHandler(GoogleLoginCommand)<br />
          export class GoogleLoginHandler {<br />
          &nbsp;&nbsp;async execute(command: GoogleLoginCommand) {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;// 사용자 생성/업데이트 로직<br />
          &nbsp;&nbsp;&nbsp;&nbsp;const user = await
          this.userGrpc.findOrCreateUser(...);<br />
          &nbsp;&nbsp;&nbsp;&nbsp;return this.jwtProvider.issueTokens(user);<br />
          &nbsp;&nbsp;}<br />
          }<br />
          <br />
          // Query<br />
          @QueryHandler(GetUserQuery)<br />
          export class GetUserHandler {<br />
          &nbsp;&nbsp;async execute(query: GetUserQuery) {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;// 읽기 전용 조회<br />
          &nbsp;&nbsp;&nbsp;&nbsp;return
          this.userQuery.findById(query.userId);<br />
          &nbsp;&nbsp;}<br />
          }
        </div>
      </div>

      <!-- Slide 10: Saga 패턴 -->
      <div class="slide">
        <h2>🎭 Saga?</h2>

        <h3>🤔 분산 트랜잭션?</h3>
        <p>
          NestJS에서의 @Saga()는
          <span class="highlight">이벤트 기반 워크플로우</span>입니다.
        </p>

        <ul>
          <li><strong>단일 서비스 내</strong> 이벤트 처리</li>
          <li><strong>비동기 작업</strong> 오케스트레이션</li>
        </ul>

        <h3>🔄 구현 예시</h3>
        <div class="code-block">
          @Injectable()<br />
          export class UserLogoutSaga {<br />
          &nbsp;&nbsp;@Saga()<br />
          &nbsp;&nbsp;userLogout = (events$: Observable&lt;any&gt;) =&gt; {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;return events$.pipe(<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ofType(UserLoggedOutEvent),<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map(event =&gt; new
          GoogleLogoutCommand(event.userId))<br />
          &nbsp;&nbsp;&nbsp;&nbsp;);<br />
          &nbsp;&nbsp;}<br />
          }
        </div>

        <h3>✅ 장점</h3>
        <ul>
          <li><strong>느슨한 결합</strong> - 이벤트 기반 통신</li>
          <li><strong>확장성</strong> - 새로운 이벤트 추가 용이</li>
        </ul>
      </div>

      <!-- Slide 11: OAuth 2.0 인증 -->
      <div class="slide">
        <h2>🔐 OAuth 2.0 인증</h2>

        <h3>🛡️ 구현 예시</h3>
        <div class="code-block">
          @Injectable()<br />
          export class GoogleStrategy extends PassportStrategy(Strategy,
          'google') {<br />
          &nbsp;&nbsp;async validate(accessToken: string, refreshToken: string,
          profile: any) {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;const { id, emails, displayName } =
          profile;<br />
          &nbsp;&nbsp;&nbsp;&nbsp;return {<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;googleId: id,<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;email: emails[0].value,<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: displayName<br />
          &nbsp;&nbsp;&nbsp;&nbsp;};<br />
          &nbsp;&nbsp;}<br />
          }
        </div>

        <h3>🔑 토큰 관리 전략</h3>
        <ul>
          <li><strong>Access Token</strong> - 15분 단기 토큰 (응답 JSON)</li>
          <li>
            <strong>Refresh Token</strong> - 7일 장기 토큰 (HttpOnly Cookie)
          </li>
          <li><strong>토큰 회전</strong> - 매번 새로운 Refresh Token 발급</li>
          <li><strong>보안 쿠키</strong> - XSS/CSRF 방지</li>
        </ul>

        <h3>🔄 인증 플로우</h3>
        <p>
          Google OAuth → JWT 발급 → Access Token(JSON) + Refresh Token(Cookie) →
          자동 갱신
        </p>
      </div>

      <!-- Slide 12: Optimistic Lock -->
      <div class="slide">
        <h2>🔒 Optimistic Lock</h2>

        <h3>💡 낙관적 잠금이란?</h3>
        <ul>
          <li><strong>충돌 가정</strong> - 동시 수정이 드물다고 가정</li>
          <li><strong>버전 관리</strong> - 데이터 변경 시 버전 증가</li>
          <li><strong>충돌 감지</strong> - 저장 시점에 버전 확인</li>
          <li><strong>성능 우선</strong> - 락 없이 높은 동시성</li>
        </ul>

        <h3>⚙️ TypeORM 구현</h3>
        <div class="code-block">
          @Entity()<br />
          export class BaseEntity {<br />
          &nbsp;&nbsp;@VersionColumn()<br />
          &nbsp;&nbsp;version: number;<br />
          }<br />
          <br />
          // Repository에서 자동 처리<br />
          public async save(user: User): Promise&lt;void&gt; {<br />
          &nbsp;&nbsp;user.setVersion(user.getVersion() + 1);<br />
          &nbsp;&nbsp;const userEntity = this.userMapper.toEntity(user);<br />
          &nbsp;&nbsp;await this.userRepository.save(userEntity); // 자동
          version 체크<br />
          }
        </div>
      </div>

      <!-- Slide 13: Docker 컨테이너화 -->
      <div class="slide">
        <h2>🐳 Docker 컨테이너화</h2>

        <h3>💡 멀티스테이지 빌드</h3>
        <ul>
          <li><strong>Builder Stage</strong> - 소스 빌드 및 의존성 설치</li>
          <li><strong>Runtime Stage</strong> - 서비스별 독립적인 컨테이너</li>
          <li><strong>Alpine Linux</strong> - 경량화된 베이스 이미지</li>
          <li><strong>Layer Caching</strong> - 빌드 시간 최적화</li>
        </ul>

        <h3>🏗️ Dockerfile 구조</h3>
        <div class="code-block">
          # Builder Stage<br />
          FROM node:22-alpine AS builder<br />
          RUN npm i -g pnpm<br />
          COPY package.json pnpm-lock.yaml ./<br />
          RUN pnpm install<br />
          COPY . .<br />
          RUN pnpm run build:all<br />
          <br />
          # Auth Service<br />
          FROM node:22-alpine AS auth<br />
          COPY --from=builder /app/dist/apps/auth ./dist<br />
          CMD ["node", "dist/src/main.js"]<br />
          <br />
          # User gRPC Service<br />
          FROM node:22-alpine AS user-grpc<br />
          COPY --from=builder /app/proto ./proto<br />
          EXPOSE 5000
        </div>

        <p>
          <strong
            >Docker 멀티스테이지 빌드로 최종 이미지에 꼭 필요한 요소만
            포함</strong
          >
        </p>
      </div>

      <!-- Slide 14: Docker Compose 오케스트레이션 -->
      <div class="slide">
        <h2>🐳 Docker Compose 오케스트레이션</h2>

        <h3>🏗️ 서비스 구성</h3>
        <div class="code-block">
          services:<br />
          &nbsp;&nbsp;# 1. 인증 서비스 (외부 진입점)<br />
          &nbsp;&nbsp;auth:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;ports: ['3000:3000']&nbsp;&nbsp;# 외부 접근
          가능<br />
          &nbsp;&nbsp;&nbsp;&nbsp;depends_on: [db, user-grpc]&nbsp;&nbsp;# DB와
          user-grpc 필요<br />
          <br />
          &nbsp;&nbsp;# 2. 사용자 HTTP API<br />
          &nbsp;&nbsp;user:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;ports: ['3001:3001']&nbsp;&nbsp;# 외부 접근
          가능<br />
          &nbsp;&nbsp;&nbsp;&nbsp;depends_on:
          [db]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# DB만 필요<br />
          <br />
          &nbsp;&nbsp;# 3. 사용자 gRPC 서비스 (내부 통신용)<br />
          &nbsp;&nbsp;user-grpc:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;# 포트 노출 없음 = 내부 통신만<br />
          &nbsp;&nbsp;&nbsp;&nbsp;depends_on: [db]<br />
          <br />
          &nbsp;&nbsp;# 4. 데이터베이스<br />
          &nbsp;&nbsp;db:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;image: mariadb:11.6.2<br />
          &nbsp;&nbsp;&nbsp;&nbsp;volumes: [dbdata:/var/lib/mysql]&nbsp;&nbsp;#
          데이터 영속성<br />
          &nbsp;&nbsp;&nbsp;&nbsp;healthcheck: # 준비 상태 확인
        </div>
      </div>

      <!-- Slide 15: 결론 -->
      <div class="slide">
        <h2>🎉 결론 및 배운 점</h2>

        <h3>✨ 핵심 성과</h3>
        <ul>
          <li>
            <strong>확장 가능한 아키텍처</strong> - Onion + CQRS +
            마이크로서비스
          </li>
          <li>
            <strong>통신 기반 서비스 분리</strong> - internal/external 통신 분리
          </li>
          <li>
            <strong>토큰 전략</strong> - Rotate Refresh Token + HttpOnly Cookie
          </li>
          <li>
            <strong>동시성 제어</strong> - Optimistic Lock으로 데이터 무결성
          </li>
          <li>
            <strong>이벤트 기반</strong> - @Saga()를 이용한 비동기 이벤트 처리
          </li>
          <li><strong>컨테이너화</strong> - Docker 멀티스테이지 빌드</li>
          <li><strong>의존성 역전</strong> - DIP로 계층 간 결합도 최소화</li>
        </ul>

        <h3>🚀 향후 확장 방향</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-number">📊</span>
            <p>모니터링<br />&amp; 로깅</p>
          </div>
          <div class="stat-card">
            <span class="stat-number">🧪</span>
            <p>테스트<br />커버리지</p>
          </div>
          <div class="stat-card">
            <span class="stat-number">🔄</span>
            <p>CI/CD<br />파이프라인</p>
          </div>
          <div class="stat-card">
            <span class="stat-number">☁️</span>
            <p>클라우드<br />배포</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll('.slide');
      const totalSlides = slides.length;

      document.getElementById('total-slides').textContent = totalSlides;

      function showSlide(n) {
        slides[currentSlide].classList.remove('active');
        currentSlide = (n + totalSlides) % totalSlides;
        slides[currentSlide].classList.add('active');

        document.getElementById('current-slide').textContent = currentSlide + 1;
      }

      function nextSlide() {
        if (currentSlide < totalSlides - 1) {
          showSlide(currentSlide + 1);
        }
      }

      function previousSlide() {
        if (currentSlide > 0) {
          showSlide(currentSlide - 1);
        }
      }

      // 키보드 네비게이션
      document.addEventListener('keydown', function (e) {
        if (e.key === 'ArrowRight' || e.key === ' ') {
          nextSlide();
        } else if (e.key === 'ArrowLeft') {
          previousSlide();
        }
      });

      // 초기 상태 설정
      showSlide(0);
    </script>
  </body>
</html>
