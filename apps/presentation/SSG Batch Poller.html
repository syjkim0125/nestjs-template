<!DOCTYPE html>
<!-- saved from url=(0113)http://127.0.0.1:3000/proto/SSG%20Batch%20Poller%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20%EB%B0%9C%ED%91%9C.html -->
<html lang="ko"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="./SSG Batch Poller 프로젝트 발표_files/___vscode_livepreview_injected_script"></script>
    
    <script type="text/javascript" src="./SSG Batch Poller 프로젝트 발표_files/___vscode_livepreview_injected_script(1)"></script>

    <script type="text/javascript" src="file:///Users/jongkkim/Desktop/%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD/SSG%20Batch%20Poller%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD_files/___vscode_livepreview_injected_script(1)"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSG Batch Poller 프로젝트 발표</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a1a 0%,
          #2d2d2d 50%,
          #1a1a1a 100%
        );
        color: white;
        overflow: hidden;
      }

      .presentation-container {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .slide {
        display: none;
        width: 90%;
        max-width: 1200px;
        background: rgba(40, 40, 40, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 60px;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: slideIn 0.6s ease-out;
      }

      .slide.active {
        display: block;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 2rem;
        text-align: center;
        background: linear-gradient(45deg, #ffd700, #ffa500);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      h2 {
        font-size: 2.5rem;
        margin-bottom: 1.5rem;
        color: #ffd700;
        border-bottom: 3px solid #ffd700;
        padding-bottom: 0.5rem;
      }

      h3 {
        font-size: 1.8rem;
        margin: 1.5rem 0 1rem 0;
        color: #87ceeb;
      }

      h4 {
        font-size: 1.4rem;
        margin: 1rem 0 0.5rem 0;
        color: #98fb98;
      }

      p,
      li {
        font-size: 1.1rem;
        line-height: 1.6;
        margin-bottom: 0.8rem;
      }

      ul {
        margin-left: 2rem;
        margin-bottom: 1rem;
      }

      li {
        margin-bottom: 0.5rem;
      }

      .code-block {
        background: rgba(20, 20, 20, 0.8);
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        font-family: 'Monaco', 'Consolas', monospace;
        font-size: 0.9rem;
        overflow-x: auto;
        border-left: 4px solid #ffd700;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .highlight {
        background: rgba(255, 215, 0, 0.2);
        padding: 0.2rem 0.5rem;
        border-radius: 5px;
        font-weight: bold;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
      }

      .stat-card {
        background: rgba(50, 50, 50, 0.8);
        padding: 1.5rem;
        border-radius: 15px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stat-number {
        font-size: 2rem;
        font-weight: bold;
        color: #ffd700;
        display: block;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
        background: rgba(50, 50, 50, 0.8);
        border-radius: 10px;
        overflow: hidden;
      }

      .comparison-table th,
      .comparison-table td {
        padding: 1rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }

      .comparison-table th {
        background: rgba(255, 215, 0, 0.2);
        font-weight: bold;
      }

      .flow-diagram {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 2rem 0;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .flow-box {
        background: rgba(60, 60, 60, 0.8);
        padding: 1rem 1.5rem;
        border-radius: 10px;
        border: 2px solid #ffd700;
        font-weight: bold;
        min-width: 180px;
        text-align: center;
        font-size: 0.95rem;
        line-height: 1.3;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 50px;
      }

      .flow-arrow {
        font-size: 1.5rem;
        color: #ffd700;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 30px;
      }

      .navigation {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1rem;
        z-index: 1000;
      }

      .nav-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 1rem 2rem;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 1rem;
        font-weight: bold;
      }

      .nav-btn:hover {
        background: rgba(255, 215, 0, 0.3);
        border-color: #ffd700;
        transform: translateY(-2px);
      }

      .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .slide-counter {
        position: fixed;
        top: 30px;
        right: 30px;
        background: rgba(40, 40, 40, 0.9);
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .pros-cons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        margin: 1.5rem 0;
      }

      .pros,
      .cons {
        background: rgba(50, 50, 50, 0.8);
        padding: 1.5rem;
        border-radius: 15px;
        border-left: 4px solid;
      }

      .pros {
        border-left-color: #98fb98;
      }

      .cons {
        border-left-color: #ffb6c1;
      }

      .emoji {
        font-size: 1.5rem;
        margin-right: 0.5rem;
      }

      .center {
        text-align: center;
      }

      .tech-stack {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        margin: 2rem 0;
      }

      .tech-item {
        background: rgba(60, 60, 60, 0.8);
        padding: 0.8rem 1.5rem;
        border-radius: 25px;
        border: 2px solid #87ceeb;
        font-weight: bold;
      }

      @media (max-width: 768px) {
        .slide {
          padding: 30px;
          width: 95%;
        }

        h1 {
          font-size: 2rem;
        }
        h2 {
          font-size: 1.8rem;
        }
        h3 {
          font-size: 1.4rem;
        }

        .stats-grid {
          grid-template-columns: 1fr;
        }

        .pros-cons {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="presentation-container">
      <!-- Slide 1: 제목 -->
      <div class="slide active">
        <div class="center">
          <h1>🚀 SSG Batch Poller 프로젝트</h1>
          <h3>트랜잭셔널 메시징을 위한 Outbox 패턴 구현</h3>

          <div class="author-info">
            <p><strong>김종건</strong></p>
            <p><strong>2025.06.16</strong></p>
          </div>
        </div>
      </div>

      <!-- Slide 2: 프로젝트 개요 -->
      <div class="slide">
        <h2>📋 프로젝트 개요</h2>

        <h3>🎯 프로젝트 배경</h3>
        <div style="display: flex; flex-direction: column">
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(255, 182, 193, 0.3)">
              지마켓 상품
            </div>
            <div class="flow-arrow">→</div>
            <div class="flow-box" style="background: rgba(135, 206, 235, 0.3)">
              SSG 연동
            </div>
          </div>
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(152, 251, 152, 0.3)">
              SSG 주문 발생
            </div>
            <div class="flow-arrow">→</div>
            <div class="flow-box" style="background: rgba(255, 215, 0, 0.3)">
              SSG 주문 스냅샷 저장
            </div>
          </div>
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(221, 160, 221, 0.3)">
              이벤트 메시지 릴레이
            </div>
            <div class="flow-arrow">→</div>
            <div class="flow-box" style="background: rgba(255, 165, 0, 0.3)">
              주문 데이터 변환
            </div>
          </div>
        </div>

        <h3>🔧 핵심 고려사항</h3>
        <ul>
          <li>
            <span class="highlight">안전한 메시지 전달</span>: SSG 주문 스냅샷 →
            이벤트 전송
          </li>
          <li>
            <span class="highlight">데이터 정합성 보장</span>: 트랜잭션 실패
            시에도 메시지 누락 방지
          </li>
          <li>
            <span class="highlight">확장 가능한 아키텍처</span>: 대용량 처리 및
            다중 이벤트 처리
          </li>
        </ul>
      </div>

      <!-- Slide 3: Outbox 패턴 -->
      <div class="slide">
        <h2>📦 Outbox 패턴 구현</h2>

        <h3>🤔 왜 Outbox 패턴인가?</h3>

        <h4>❌ 기존 방식의 문제점</h4>
        <div class="code-block">
          @Transactional fun processEvent(event: Event) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;database.save(event) // DB 저장 성공<br>
          &nbsp;&nbsp;&nbsp;&nbsp;kafkaProducer.send(event) // Kafka 전송 실패 →
          불일치!<br>
          }
        </div>

        <h4>✅ Outbox 패턴 해결 방안</h4>
        <div class="code-block">
          @Transactional fu processEvent(event: Event) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;database.save(event) // 1. DB에 저장<br>
          &nbsp;&nbsp;&nbsp;&nbsp;outboxTable.save(event) // 2. Outbox에 저장
          (같은 트랜잭션)<br>
          }<br>
          <br>
          // 별도 배치에서 Outbox → Kafka 전송
        </div>

        <div class="pros-cons">
          <div class="pros">
            <h4><span class="emoji">✅</span>장점</h4>
            <ul>
              <li>데이터 무결성 보장</li>
              <li>성능 최적화</li>
              <li>독립적 모니터링</li>
              <li>유연한 복구</li>
            </ul>
          </div>
          <div class="cons">
            <h4><span class="emoji">⚠️</span>고려사항</h4>
            <ul>
              <li>구현 복잡성 증가</li>
              <li>두 테이블 간 일관성 관리</li>
              <li>추가적인 저장 공간</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Slide 4: 아키텍처 설계 -->
      <div class="slide">
        <h2>🏗️ 아키텍처 설계</h2>

        <h3>🔄 전체 데이터 플로우</h3>

        <h4>📊 메인 처리 플로우</h4>
        <div class="flow-diagram" style="margin: 1.5rem 0; gap: 0.5rem">
          <div class="flow-box" style="
              background: rgba(255, 182, 193, 0.3);
              min-width: 120px;
              font-size: 0.85rem;
            ">
            이벤트 테이블
          </div>
          <div class="flow-arrow">→</div>
          <div class="flow-box" style="
              background: rgba(135, 206, 235, 0.3);
              min-width: 80px;
              font-size: 0.85rem;
            ">
            Read
          </div>
          <div class="flow-arrow">→</div>
          <div class="flow-box" style="
              background: rgba(152, 251, 152, 0.3);
              min-width: 80px;
              font-size: 0.85rem;
            ">
            Process
          </div>
          <div class="flow-arrow">→</div>
          <div class="flow-box" style="
              background: rgba(255, 215, 0, 0.3);
              min-width: 80px;
              font-size: 0.85rem;
            ">
            Write
          </div>
          <div class="flow-arrow">→</div>
          <div class="flow-box" style="
              background: rgba(221, 160, 221, 0.3);
              min-width: 80px;
              font-size: 0.85rem;
            ">
            Kafka
          </div>
        </div>

        <h4>🔄 오프셋 관리</h4>
        <div class="flow-diagram" style="margin: 1rem 0; gap: 0.5rem">
          <div class="flow-box" style="
              background: rgba(255, 165, 0, 0.3);
              min-width: 120px;
              font-size: 0.85rem;
            ">
            오프셋 테이블
          </div>
          <div class="flow-arrow">←</div>
          <div class="flow-box" style="
              background: rgba(255, 192, 203, 0.3);
              min-width: 100px;
              font-size: 0.85rem;
            ">
            위치 저장
          </div>
        </div>

        <h3>🎯 설계 원칙</h3>
        <ul>
          <li>
            <span class="highlight">관심사 분리</span>: 이벤트 데이터와 처리
            상태 분리
          </li>
          <li>
            <span class="highlight">복구 가능성</span>: 실패 시 마지막 처리
            지점부터 재시작
          </li>
          <li>
            <span class="highlight">확장성</span>: 여러 배치 타입 지원 가능
          </li>
        </ul>
      </div>

      <!-- Slide 5: 테이블 구조 및 확장성 -->
      <div class="slide">
        <h2>🗄️ 테이블 구조 및 확장성</h2>

        <h3>📊 핵심 테이블</h3>
        <div style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
          ">
          <div class="code-block">
            <strong>SSG_LINK_SNAPSHOT (이벤트 테이블)</strong><br>
            • SSG_LINK_SNAPSHOT_EVENT_SEQ (PK): 순차 증가 ID<br>
            • SNAPSHOT_KEY: SSG 스냅샷 키<br>
            <br>
            <span style="color: #98fb98">→ 실제 비즈니스 데이터 저장</span>
          </div>

          <div class="code-block">
            <strong>EVENT_BATCH_OFFSET (오프셋 테이블)</strong><br>
            • EVENT_BATCH_OFFSET_SEQ (PK): 순차 증가 ID<br>
            • BATCH_NAME: 배치 이름<br>
            • BATCH_OFFSET: 마지막 처리 오프셋 (이벤트 테이블의 SEQ Key)<br>
            <br>
            <span style="color: #87ceeb">→ 처리 위치 추적 및 관리</span>
          </div>
        </div>

        <h3>🎯 확장성</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>확장 포인트</th>
              <th>구현 방식</th>
              <th>장점</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>다중 이벤트 타입</td>
              <td>BATCH_NAME으로 구분</td>
              <td>하나의 오프셋 테이블로 여러 배치 관리</td>
            </tr>
            <tr>
              <td>독립적 처리</td>
              <td>배치별 개별 오프셋</td>
              <td>각 배치가 서로 영향 없이 처리 (Append-Only)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Slide 6: 중복 방지 메커니즘 -->
      <div class="slide">
        <h2>🛡️ 중복 방지 메커니즘</h2>

        <h3>3단계 중복 방지 전략</h3>

        <div style="
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin: 2rem 0;
          ">
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(152, 251, 152, 0.2); min-width: 280px">
              Level 1: Application (Offset 기반)
            </div>
            <div class="flow-arrow">→</div>
            <div style="min-width: 250px; text-align: left; font-size: 0.95rem">
              마지막 처리된 offset 이후만 조회
            </div>
          </div>
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(135, 206, 235, 0.2); min-width: 280px">
              Level 2: Kafka Producer
            </div>
            <div class="flow-arrow">→</div>
            <div style="min-width: 250px; text-align: left; font-size: 0.95rem">
              Idempotent Producer, acks config 설정
            </div>
          </div>
          <div class="flow-diagram">
            <div class="flow-box" style="background: rgba(255, 215, 0, 0.2); min-width: 280px">
              Level 3: Message (eventKey 기반)
            </div>
            <div class="flow-arrow">→</div>
            <div style="min-width: 250px; text-align: left; font-size: 0.95rem">
              Consumer 측에서 중복 제거
            </div>
          </div>
        </div>

        <h3>🎯 중복 시나리오별 대응</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>시나리오</th>
              <th>발생 원인</th>
              <th>방지 메커니즘</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>재시작 중복</td>
              <td>장애 후 재시작</td>
              <td>Level 1: Offset 체크</td>
            </tr>
            <tr>
              <td>네트워크 재전송</td>
              <td>Kafka 통신 장애</td>
              <td>Level 2: Idempotent Producer, acks config</td>
            </tr>
            <tr>
              <td>Consumer 중복</td>
              <td>메시지 재처리</td>
              <td>Level 3: eventKey 기반</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Slide 7: 처리량 분석 및 설정 최적화 -->
      <div class="slide">
        <h2>📊 처리량 분석 및 설정 최적화</h2>

        <h3>📈 이론적 처리 용량 (5초마다 20개 청크)</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-number">345,600개</span>
            <span>이론적 일일 처리량</span>
          </div>
        </div>

        <h3>⚡ Dev 성능 측정 결과</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>청크 크기</th>
              <th>총 처리 시간</th>
              <th>이벤트당 시간</th>
              <th>처리량/초</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>5개 (소량)</td>
              <td>182ms</td>
              <td>36.4ms</td>
              <td>27.5개/초</td>
            </tr>
            <tr>
              <td>25개 (중간)</td>
              <td>234ms</td>
              <td>9.4ms</td>
              <td>106.8개/초</td>
            </tr>
            <tr>
              <td>100개 (대량)</td>
              <td>391ms</td>
              <td>3.9ms</td>
              <td>255.8개/초</td>
            </tr>
          </tbody>
        </table>

        <h3>📊 시간 분석 및 최적화 포인트</h3>
        <div class="code-block">
          <strong>실제 관측 후 최적화</strong><br>
          실제 일일 주문량: 2,500건<br>
          배치 주기: 5초 -&gt; 20초<br>
          청크 크기: 20개 -&gt; 5개<br>
          일일 처리량: 345,600개 -&gt; 21,600개(8~9배 여유)<br>
          <br>
          <strong>시나리오: 장애 후 1,000개 이벤트 누적</strong><br>

          처리 방식: 1,000개 ÷ 5개 = 200번 배치<br>
          실제 처리 시간: 182ms × 200 = 36.4초<br>
          배치 간격 포함: 200 × 20초 = 67분<br>
          결과: 안정적 복구 가능 ✅<br>
          <br>
          <strong>최적화 결론:</strong><br>
          • 현재 설정으로도 충분한 여유 용량<br>
          • 대량 처리 시, 시간 조정 or 청크 크기 증가로 효율성 향상
        </div>
      </div>

      <!-- Slide 8: 결론 및 Q&A -->
      <div class="slide">
        <h2>🎯 결론 및 핵심 포인트</h2>
        <ul>
          <li>
            <span class="highlight">Outbox 패턴</span>: 분산 시스템에서 데이터
            일관성 보장
          </li>
          <li>
            <span class="highlight">실측 기반 최적화</span>: 예상(5초/20개)에서
            실측(20초/5개)으로 전략 변경
          </li>
          <li>
            <span class="highlight">장애 상황 대응</span>: 장애 복구 시나리오
            시뮬레이션과 안정성 확보
          </li>
          <li>
            <span class="highlight">확장성 고려 설계</span>: 다양한 이벤트 타입
            처리 가능
            <br>
            <span style="margin-left: 1.5rem; font-size: 0.9rem; color: #aaa">
              → 멀티 스레드, 다중 인스턴스 처리는 추가 고려 필요
            </span>
          </li>
        </ul>
      </div>
    </div>

    <!--
        ========================================
        📝 확장성 전략 상세 답변 (발표자 참고용)
        ========================================

        🧵 멀티스레드 PK 해시 파티셔닝 전략:

        1. 구현 방식:
        ```kotlin
        fun assignThread(eventId: Long): Int {
            return (eventId % threadCount).toInt()
        }
        
        // 각 스레드별 쿼리
        Thread 1: SELECT * FROM SSG_LINK_SNAPSHOT 
                  WHERE id > ? AND id % 4 = 0 
                  ORDER BY id LIMIT 5
        ```

        2. 장점:
        - 오프셋 순서 보장 문제 해결 (각 스레드가 독립적 ID 범위)
        - DB 락 경합 최소화 (서로 다른 ID 범위 접근)
        - 부하 균등 분산 (PK 해시로 균등 분배)
        - 거의 이론적 최대치 성능 (3.5-4배)

        3. DB 물리적 파티셔닝과 시너지:
        ```sql
        CREATE TABLE SSG_LINK_SNAPSHOT (
            id BIGINT PRIMARY KEY,
            ...
        ) PARTITION BY HASH(id) PARTITIONS 4;
        ```

        🔀 멀티배치 + DB 샤딩 전략:

        1. 샤딩 방식:
        - 수평 샤딩: 여러 DB 인스턴스에 데이터 분산
        - eventKey 해시값으로 샤드 결정
        - 각 배치가 독립적으로 다른 샤드 처리

        2. 장점:
        - DB I/O 분산으로 병목 해소
        - 독립적 확장 가능 (샤드별 스케일링)
        - 장애 격리 (한 샤드 장애가 다른 샤드에 영향 없음)

        3. 고려사항:
        - 크로스 샤드 트랜잭션 복잡성
        - 샤드 리밸런싱 필요성
        - 운영 복잡성 증가

        📊 성능 예상 근거:

        1. 현재 (1배): 182ms/5개 = 36.4ms/이벤트
        2. PK 해시 멀티스레드 (3.5-4배):
           - 이론적 4배에서 오버헤드 10-15% 감안
           - 리소스 경합 최소화로 거의 이론치 달성
        3. 멀티배치 추가 (5-6배):
           - 도메인별 독립 처리로 추가 1.5-2배 향상
        4. DB 샤딩 (8-10배):
           - I/O 병목 해소로 추가 1.5-2배 향상

        🎯 구현 우선순위:

        1단계: PK 해시 멀티스레드
        - 가장 큰 성능 향상 (3.5-4배)
        - 상대적으로 단순한 구현
        - 기존 구조 최소 변경

        2단계: 멀티배치 도입
        - 도메인별 독립성 확보
        - 장애 격리 효과
        - 운영 관리 용이성

        3단계: DB 샤딩
        - 최대 성능 필요 시점에서 도입
        - 복잡성 대비 효과 검증 후 진행
        - 운영팀 역량 고려 필수

        💡 면접 답변 포인트:

        Q: "왜 PK 해시 파티셔닝을 선택했나요?"
        A: "오프셋 순서 보장 문제를 근본적으로 해결하면서도 DB 경합을 최소화할 수 있는 가장 효율적인 방법이기 때문입니다. 각 스레드가 독립적인 ID 범위를 처리하므로 복잡한 동기화 없이도 거의 이론적 최대 성능을 달성할 수 있습니다."

        Q: "샤딩 도입 시점은 언제인가요?"
        A: "현재 2,500건에서 10만건 이상으로 증가할 때 고려하겠습니다. 그 전까지는 멀티스레드와 멀티배치로 충분히 대응 가능하고, 샤딩은 운영 복잡성이 크므로 명확한 필요성이 확인된 후 도입하는 것이 바람직합니다."



            
            <div class="slide">
                <h2>🚀 확장성 고려사항</h2>

                <h3>📈 대용량 처리 시나리오</h3>

                <h4>🔑 PK 기준 해시 파티셔닝</h4>
                <div class="code-block">
                    Thread 1: ID % 4 = 0 (1, 5, 9, 13, ...)<br />
                    Thread 2: ID % 4 = 1 (2, 6, 10, 14, ...)<br />
                    Thread 3: ID % 4 = 2 (3, 7, 11, 15, ...)<br />
                    Thread 4: ID % 4 = 3 (4, 8, 12, 16, ...)
                </div>

                <h4>🔀 멀티 배치 + DB 샤딩</h4>
                <div class="code-block">
                    Shard 1: eventKey hash % 4 = 0 → DB1<br />
                    Shard 2: eventKey hash % 4 = 1 → DB2<br />
                    Shard 3: eventKey hash % 4 = 2 → DB3<br />
                    Shard 4: eventKey hash % 4 = 3 → DB4
                </div>

                <h3>⚖️ 확장 전략 로드맵</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>처리량</th>
                            <th>권장 전략</th>
                            <th>예상 성능</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>~1만건/일</td>
                            <td>현재 구조 유지</td>
                            <td>1배 (기준)</td>
                        </tr>
                        <tr>
                            <td>1만~5만건/일</td>
                            <td>PK 해시 멀티스레드</td>
                            <td>3.5-4배</td>
                        </tr>
                        <tr>
                            <td>5만~10만건/일</td>
                            <td>멀티 배치 추가</td>
                            <td>5-6배</td>
                        </tr>
                        <tr>
                            <td>10만건 이상/일</td>
                            <td>DB 샤딩 + 멀티 배치</td>
                            <td>8-10배</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        -->

    <div class="slide-counter">
      <span id="current-slide">1</span> /
      <span id="total-slides">8</span>
    </div>

    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll('.slide');
      const totalSlides = slides.length;

      document.getElementById('total-slides').textContent = totalSlides;

      function showSlide(index) {
        slides.forEach((slide) => slide.classList.remove('active'));
        slides[index].classList.add('active');

        document.getElementById('current-slide').textContent = index + 1;

        // 버튼 상태 업데이트
        document.getElementById('prev-btn').disabled = index === 0;
        document.getElementById('next-btn').disabled =
          index === totalSlides - 1;
      }

      function nextSlide() {
        if (currentSlide < totalSlides - 1) {
          currentSlide++;
          showSlide(currentSlide);
        }
      }

      function previousSlide() {
        if (currentSlide > 0) {
          currentSlide--;
          showSlide(currentSlide);
        }
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }

      // 키보드 내비게이션
      document.addEventListener('keydown', function (event) {
        switch (event.key) {
          case 'ArrowRight':
          case ' ':
          case 'PageDown':
            nextSlide();
            break;
          case 'ArrowLeft':
          case 'PageUp':
            previousSlide();
            break;
          case 'Home':
            currentSlide = 0;
            showSlide(currentSlide);
            break;
          case 'End':
            currentSlide = totalSlides - 1;
            showSlide(currentSlide);
            break;
          case 'F11':
            event.preventDefault();
            toggleFullscreen();
            break;
        }
      });

      // 마우스 휠 내비게이션
      document.addEventListener('wheel', function (event) {
        if (event.deltaY > 0) {
          nextSlide();
        } else {
          previousSlide();
        }
      });

      // 터치 스와이프 지원 (모바일)
      let touchStartX = 0;
      let touchEndX = 0;

      document.addEventListener('touchstart', function (event) {
        touchStartX = event.changedTouches[0].screenX;
      });

      document.addEventListener('touchend', function (event) {
        touchEndX = event.changedTouches[0].screenX;
        handleSwipe();
      });

      function handleSwipe() {
        if (touchEndX < touchStartX - 50) {
          nextSlide();
        }
        if (touchEndX > touchStartX + 50) {
          previousSlide();
        }
      }

      // 초기 설정
      showSlide(0);
    </script>
  

</body></html>